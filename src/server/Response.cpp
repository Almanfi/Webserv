/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Response.cpp                                       :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: maboulkh <maboulkh@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2023/11/20 05:16:29 by maboulkh          #+#    #+#             */
/*   Updated: 2023/11/20 07:51:21 by maboulkh         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "webserv.hpp"

size_t Response::write(char *buffer, size_t size) {
    size_t count = 0;
    if (_header.size()) {
        count = (size < _header.size()) ? size : _header.size();
        std::memmove(buffer, _header.c_str(), count);
        _header = _header.substr(count);
    }
    // else {
    //     if (!this->size)
    //         return (0);
    //     count = (size < this->size) ? size : this->size;
    //     if (isFile) {
    //         file.read(buffer, count);
    //     }
    //     else {
    //         std::memmove(buffer, data.c_str(), count);
    //         data = data.substr(count);
    //     }
    //     this->size -= count;
    // }
    return (count);
}
	// code[100] = "Continue"; when client send H-  Expect: 100-continue respond with 100 for him to continue sending body
	// code[200] = "OK"; 
	// code[201] = "Created"; probably work with cgi and read its generated headers 
	// code[204] = "No Content"; might not be used as it s generated by a PUT method but make sure no body is sent(MUST)
	// code[400] = "Bad Request"; probably to signal any parsing error (the .. or . or even /(empt)/ could be respoonded to by this)
	// code[403] = "Forbidden"; (not sure but a post on a url that has a file return this)
	// code[404] = "Not Found"; (for both GET and POST in Post case return "not found as body but nort sure if nginx behave the same")
	// code[405] = "Method Not Allowed"; "if the method is npot aloowed and the respons must contain Allow: <http-methods>"
	// code[413] = "Payload Too Large"; check the server request body limit nginx called 'client_max_body_size';
	// code[500] = "Internal Server Error"; 


Response::Response(std::string& code, std::string& data) : code(code), data(data) {
    ResponseHeader["Server"] = "webserv"; // sever.name();
    ResponseHeader["date"] = date(); // date();
    std::stringstream ss;
    ss << code;
    int codeNb;
    ss >> codeNb;
    if (codeNb == 201 || codeNb == 303 || codeNb == 307 || codeNb == 308 || codeNb == 302)
        ResponseHeader["Location"] = newUrl();
    if (codeNb == 405)
        ResponseHeader["Allow"] = AllowedMethod(); // Allow: GET, POST, HEAD
    // if (code == 201(created) , 303 (See Other), 307 (Temporary Redirect), 308 (Permanent Redirect), 301 (Moved Permanently), 302 (Found))
    //     ResponseHeader["Location"] = "/index.html"; resorce url
    // if (code == 405(method not allowed))
    //     ResponseHeader["Allow"] = "<http-methods>"; // Allow: GET, POST, HEAD
    file.open(data.c_str());
    ResponseHeader["content-type"] = findType(data); // content.findType();
    ResponseHeader["content-length"] = contentLength(); // content.lenth();
}

std::string Response::AllowedMethod() {
    //config.method();
    return (std::string("GET"));
}

std::string Response::newUrl() {
    return (std::string("/index.html"));
}


// Response::Response(std::string& body)
// {
//     StatusCode a;

//     fileName = "";
//     code = "200";
//     std::string StatusLine = a.statusLine(code);
//     // "HTTP-Version Status-Code Reason-Phrase\r\n"; //server.httpVer() + " " + status + phrase(status) + "\r\n";
//     ResponseHeader["Server"] = "webserv"; // sever.name();
//     ResponseHeader["date"] = date(); // date();
//     ResponseHeader["content-type"] = findType(fileName); // content.findType();
//     ResponseHeader["content-length"] = contentLength(); // content.lenth();

// /*
// HTTP/1.1 200 OK
// date: Fri, 17 Nov 2023 16:48:57 GMT
// content-type: text/html; charset=utf-8
// content-length: 1017
// x-request-id: a1bce949-f6af-4226-92a1-d746484b8a79
// cache-control: no-store, max-age=0
// accept-ch: sec-ch-prefers-color-scheme
// critical-ch: sec-ch-prefers-color-scheme
// vary: sec-ch-prefers-color-scheme
// x-adblock-key: MFwwDQYJKoZIhvcNAQEBBQADSwAwSAJBANDrp2lz7AOmADaN8tA50LsWcjLFyQFcb/P2Txc58oYOeILb3vBw7J6f4pamkAQVSQuqYsKx3YzdUHCvbVZvFUsCAwEAAQ==_HDSApIK32dE8tmarsVRiNoDCy6ChdPP5Uy8Jjf116Tqg7be9w+AIiANsZh2PU+muk1bDI2ehY575ZFEH0KlcHA==
// set-cookie: parking_session=a1bce949-f6af-4226-92a1-d746484b8a79; expires=Fri, 17 Nov 2023 17:03:57 GMT; path=/
// */

// }

std::string Response::header() {
    std:: string header;
    std::string SP = "\r\n";
    StatusCode a;

    header = a.statusLine(code);
    header += SP;
    for (std::map<std::string, std::string>::iterator it = ResponseHeader.begin(); it != ResponseHeader.end(); it++)
        header += it->first + ": " + it->second + SP;
    header += SP;
    _header = header;
    return (header);
}

std::string Response::body() {
    return (data);
}

std::string Response::contentLength() {
    std::stringstream ss;
    std::ifstream file(data.c_str());
    if (!file.is_open())
    {
        // throw
        code = "500";
        std::cerr << "file not found" << std::endl;
        return "";
    }
    std::streampos start = file.tellg();
    file.seekg(0, std::ios::end);
    std::streampos end = file.tellg();
    size = end - start;
    file.close();
    ss << size;
    return (ss.str());
}

std::string Response::date() {
    std::time_t   nowTime = std::time(NULL);
    std::tm* gmTime = std::gmtime(&nowTime);

    char    buffer[100];
    std::strftime(buffer, sizeof(buffer), "%a, %d %b %Y %X GMT", gmTime);
    return ((std::string) buffer);
}

std::string Response::findType(const char* fileName) {
    std::string fileNameString = std::string(fileName);
    return (findType(fileNameString));
}

std::string Response::findType(std::string& fileName) {
    std::map<std::string, std::string> type;
    type["default"] = "application/octet-stream";
    type[".aac"] = "audio/aac";
    type[".abw"] = "application/x-abiword";
    type[".arc"] = "application/x-freearc";
    type[".avif"] = "image/avif";
    type[".avi"] = "video/x-msvideo";
    type[".azw"] = "application/vnd.amazon.ebook";
    type[".bin"] = "application/octet-stream";
    type[".bmp"] = "image/bmp";
    type[".bz"] = "application/x-bzip";
    type[".bz2"] = "application/x-bzip2";
    type[".cda"] = "application/x-cdf";
    type[".csh"] = "application/x-csh";
    type[".css"] = "text/css";
    type[".csv"] = "text/csv";
    type[".doc"] = "application/msword";
    type[".docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document";
    type[".eot"] = "application/vnd.ms-fontobject";
    type[".epub"] = "application/epub+zip";
    type[".gz"] = "application/gzip";
    type[".gif"] = "image/gif";
    type[".htm"] = "text/html";
    type[".html"] = "text/html";
    type[".ico"] = "image/vnd.microsoft.icon";
    type[".ics"] = "text/calendar";
    type[".jar"] = "application/java-archive";
    type[".jpg"] = "image/jpeg";
    type[".jpeg"] = "image/jpeg";
    type[".js"] = "text/javascript";
    type[".json"] = "application/json";
    type[".jsonld"] = "application/ld+json";
    type[".mid"] = "audio/midi, audio/x-midi";
    type[".midi"] = "audio/midi, audio/x-midi";
    type[".mjs"] = "text/javascript";
    type[".mp3"] = "audio/mpeg";
    type[".mp4"] = "video/mp4";
    type[".mpeg"] = "video/mpeg";
    type[".mpkg"] = "application/vnd.apple.installer+xml";
    type[".odp"] = "application/vnd.oasis.opendocument.presentation";
    type[".ods"] = "application/vnd.oasis.opendocument.spreadsheet";
    type[".odt"] = "application/vnd.oasis.opendocument.text";
    type[".oga"] = "audio/ogg";
    type[".ogv"] = "video/ogg";
    type[".ogx"] = "application/ogg";
    type[".opus"] = "audio/opus";
    type[".otf"] = "font/otf";
    type[".png"] = "image/png";
    type[".pdf"] = "application/pdf";
    type[".php"] = "application/x-httpd-php";
    type[".ppt"] = "application/vnd.ms-powerpoint";
    type[".pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation";
    type[".rar"] = "application/vnd.rar";
    type[".rtf"] = "application/rtf";
    type[".sh"] = "application/x-sh";
    type[".svg"] = "image/svg+xml";
    type[".tar"] = "application/x-tar";
    type[".tif"] = "image/tiff";
    type[".tiff"] = "image/tiff";
    type[".ts"] = "video/mp2t";
    type[".ttf"] = "font/ttf";
    type[".txt"] = "text/plain";
    type[".vsd"] = "application/vnd.visio";
    type[".wav"] = "audio/wav";
    type[".weba"] = "audio/webm";
    type[".webm"] = "video/webm";
    type[".webp"] = "image/webp";
    type[".woff"] = "font/woff";
    type[".woff2"] = "font/woff2";
    type[".xhtml"] = "application/xhtml+xml";
    type[".xls"] = "application/vnd.ms-excel";
    type[".xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet";
    type[".xml"] = "application/xml";
    type[".xul"] = "application/vnd.mozilla.xul+xml";
    type[".zip"] = "application/zip";
    type[".3gp"] = "video/3gpp;";
    type[".3g2"] = "video/3gpp2;";
    type[".7z"] = "application/x-7z-compressed";
    
    size_t i = fileName.find_last_of('.');
    if (i == std::string::npos)
        return (type["default"]);
    std::map<std::string, std::string>::const_iterator res = type.find(fileName.substr(i));
    if (res != type.end())
        return (res->second);
    else
        return (type["default"]);
}

Response::~Response() {
if (file.is_open())
    file.close();
}
